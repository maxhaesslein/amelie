#!/usr/bin/python


# Amelie v3, 2023
# by maxhaesslein, 2018-2023
# www.maxhaesslein.de


# dependencies: opencv, picamera2
# sudo apt install python3-opencv python3-picamera2
# sudo apt install xserver-xorg xinit
#
# start with:
# startx /home/mh/amelie/amelie


import cv2
from picamera2 import Picamera2
from libcamera import controls
from gpiozero import RGBLED, Button
from configparser import ConfigParser
import time
import cups
import sys
import os
import shutil


options = {

    'configPath': '/mnt/amelie-usb/',

    'outputDirectory': '/home/mh/amelie/images/',
    'tempDirectory': '/home/mh/amelie/temp/',
    'backupDirectory': False,

    'windowName': 'Amelie',
    'windowWidth': 720,
    'windowHeight': 720,

    # max resolution of camera module 3 is 4608x2592
    'captureWidth': 2592,
    'captureHeight': 2592,

    'printWidth': 384,
    'printHeight': 384,

    'continuousAutofocus': True,

    'printerName': 'ZJ-58',
    'printerActive': False,

    # PIN numbers are GPIO/BCM numbers
    'pinR': 17,
    'pinG': 27,
    'pinB': 22,
    'pinButton': 23,

    'font': cv2.FONT_HERSHEY_DUPLEX,
    'fontSize': 3,

}


print('amelie v.3')



# check for config file and read options
if os.path.isfile(options['configPath']+'amelie.txt'):
    configParser = ConfigParser()
    configParser.read(options['configPath']+'amelie.txt')
    for option in options:

        if configParser.has_option('Amelie', option):
            options[option] = configParser.get('Amelie', option)

        if options[option] == "False":
            options[option] = False
        elif options[option] == "True":
            options[option] = True
        elif option == "pinR" or option == "pinG" or option == "pinB" or option == "pinButton" or option == 'fontSize' or option == 'windowWidth' or option == 'windowHeight' or option == 'captureWidth' or option == 'captureHeight' or option == 'printWidth' or option == 'printHeight':
            options[option] = int(options[option])


# check if backupDirectory exists
if not os.path.isdir(options['backupDirectory']):
    options['backupDirectory'] = False



print(options)



# setup GPIOs
led = RGBLED( red=options['pinR'], green=options['pinG'], blue=options['pinB'], active_high = False )
button = Button( pin=options['pinButton'], pull_up=None, active_state=True )

currentColor = False
def setColor( color ):
    global currentColor

    if color == currentColor:
        return

    if color == 'red':
        led.color = (1,0,0)
    elif color == 'green':
        led.color = (0,1,0)
    elif color == 'blue':
        led.color = (0,0,1)
    elif color == 'white':
        led.color = (1,1,1)
    else:
        led.color = (0,0,0)

    currentColor = color

setColor('white')

# setup printer
cupsConnection = cups.Connection()
cups.setUser('mh')
printers = cupsConnection.getPrinters()
printerFound = False
for printer in printers:
    if str(printer) == options['printerName']:
        printerFound = printer
if not printerFound:
    print('Printer not found.')
    sys.exit()


# setup picam
picam = Picamera2()

picam.configure(
    picam.create_still_configuration(
        main={
            "size": (options['captureWidth'], options['captureHeight']),
            "format": "RGB888",
        },
        lores={
            "size": (options['windowWidth'], options['windowHeight'])
            # lores format is always YUV420
        },
    )
)

picam.start()

if options['continuousAutofocus']:
    picam.set_controls({"AfMode": controls.AfModeEnum.Continuous})


# setup window
cv2.namedWindow( options['windowName'], cv2.WINDOW_NORMAL )
cv2.resizeWindow( options['windowName'], options['windowWidth'], options['windowHeight'] )
cv2.setWindowProperty( options['windowName'], cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN )



printJobId = False
fileName = False
printFileName = False
timestamp = False
state = 'idle'

# main loop
while True:
    preview = picam.capture_array("lores")

    # because the lores stream is always YUV420, we need to convert it:
    im = cv2.cvtColor( preview, cv2.COLOR_YUV420p2RGB )
    # and crop it:
    im = im[0:options['windowWidth'], 0:options['windowHeight']]
    # and mirror it:
    im = cv2.flip( im, 1 )

    cv2.putText( im, state, (10,80), options['font'], options['fontSize'], (0,255,0), 2, cv2.LINE_AA ) # DEBUG

    cv2.imshow( options['windowName'], im )
    key = cv2.waitKey(1)


    if state == 'capture':
        setColor('blue')

        timestamp = str(int(time.time()))

        fileName = options['outputDirectory']+timestamp+'.jpg'
        picam.capture_file(fileName, wait=True)

        if options['backupDirectory']:
            backupFileName = options['backupDirectory']+timestamp+'.jpg'
            os.system('cp '+fileName+' '+backupFileName )

        state = 'prepare'

    elif state == 'prepare':
        setColor('blue')

        printImage = cv2.imread( fileName, cv2.IMREAD_GRAYSCALE)
        printImage = cv2.resize( printImage, (options['printWidth'], options['printHeight']) )

        printFileName = options['tempDirectory']+timestamp+'_print.jpg'
        cv2.imwrite( printFileName, printImage )

        fileName = False
        timestamp = False

        state = 'print'

    elif state == 'print':
        setColor('red')

        if options['printerActive']:

            if not printJobId:
                printJobId = cupsConnection.printFile( printerFound, printFileName, options['windowName'], {} )

            elif not cupsConnection.getJobs().get(printJobId, None): # finished printing

                printJobId = False

                state = 'cleanup'

        else:

            state = 'cleanup'

    elif state == 'cleanup':
        setColor('red')

        os.remove( printFileName )
        printFileName = False
        state = 'idle'

    else:
        # idle
        setColor('green')

        if button.is_pressed:
            state = 'capture'


    if key == 27: # escape
        break

    elif key == 32: # space

        if state == 'idle':
            state = 'capture'

    elif key == 13: # enter
        picam.autofocus_cycle(wait=False) # trigger autofocus async


print( 'bye ...' )

